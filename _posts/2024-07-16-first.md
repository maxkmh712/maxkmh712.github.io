---
layout: single
title: "[ DATABASE ] 정규화와 반정규화"
typora-root-url: ../
categories: [📌 DATABASE]
tag: [정규화, 반정규화]
author_profile: false # 연락처 정보 숨기기
sidebar: # 사이드바 네이게이션 수정
  # nav: "docs" # /_data/navigation.yml의 docs를 의미
  nav: "counts"
search: true
---

# ![database-normalization](/images/2024-07-16-first/database-normalization.jpg)

# 정규화(Normalization)

## 1. 개념

정규화란 엔티티를 작은 단위로 분리하는 과정 혹은 방법이다. 작은 단위로 분리한다는 것은 중점적으로 불필요한 데이터들의 중복을 제거한다는 말이고, 이는 이상현상(Anomaly)을 방지하여 데이터를 논리적으로 저장하기 위한 목적이다. 여기서 이상현상이란 아래와 같이 크게 세가지로 들 수 있다.

| 학번 | 이름   | 성별 | 나이 | 강의코드 | 강의명          |
| ---- | ------ | ---- | ---- | -------- | --------------- |
| 2401 | 김갱신 | 남   | 21   | ABC1     | 네트워크 개론   |
| 2402 | 김삽입 | 여   | 22   | ABC1     | 네트워크 개론   |
| 2403 | 김삭제 | 남   | 23   | ABC2     | 알고리즘 뿌수기 |

1) 갱신 이상 (Modification Anomaly) 

   중복된 데이터 중 일부만 갱신될 시 데이터의 불일치, 즉 데이터 정합성 문제가 발생한다. 정합성이란 어떤 데이터들의 값이 서로 일치하지 않는 상태를 말한다. 예를 들어, 위 테이블에서 강의명이 있지만, 강의 정보만 있는 강의테이블이 추가로 있다고 가정할 경우, 강의테이블에서만 강의명이 바뀔경우 위 테이블의 강의명은 변경되지 않았기 때문에 정합성이 깨져 갱신이상 문제가 발생한다고 볼 수 있다.

2) 삽입 이상 (Insertion Anomaly)

   데이터를 저장할 때 불필요하거나 의도하지 않은 정보를 반드시 저장해야만 본 데이터를 저장할 수 있게 되는 상황이다. 위 테이블에서 학생의 정보를 삽입하려고 할 때, 그 학생이 강의를 듣지 않은 경우에는 강의코드와 강의명에 null이 들어가야 하는 삽입 이상이 생긴다.

3) 삭제 이상 (Deletion Anomaly)

   어떤 정보를 삭제하면, 의도하지 않은 정보까지 삭제되어버리는 현상이다. 위 테이블에서 강의 정보만 삭제하고 싶어서 ABC2를 삭제해버리면 학번 2403 데이터 전체가 삭제되어버리는 삭제 이상이 발생한다.

이러한 이상 현상을 예방하기 위해 데이터 정규화가 필요하다. 정규화는 상태에 따라 단계를 나눠 진행한다.



## 2. 단계

💡정규화 vs 정규형 용어 차이

공부를 하다보니 `정규형`이라는 말과 `정규화` 라는 말이 헷갈려 구글링해가며 나름 개념 정리한 것을 공유하고자 한다.정규형은 **형태, 상태**를 나타내는 말이고, 정규화는 ~화 한다는 말로 **과정, 방법**이라고 이해했다. 정규화는 통상적으로 아래와 같은 단계로 구분할 수 있다.

### 1) 1차 정규형 & 1차 정규화(1NF)

**1차 정규형**이란 **하나의 속성에는 하나의 속성값만 가져야 한다는 상태**를 나타낸다.

| Id   | 이름 | 나이 | 수강과목       |
| ---- | ---- | ---- | -------------- |
| 1    | 이더 | 21   | 중국어, 일본어 |
| 2    | 만호 | 22   | 독일어         |
| 3    | 보리 | 23   | 한국어         |

위 테이블에서는 수강과목에서 이더가 수강과목에 2가지 속성값을 가지고 있기 때문에 1차 정규형이라는 상태에 위배된다. 즉, **원자값만을 포함하는 상태로 만들어줘야 하는 방법을 제 1정규화**라고 한다. 위 테이블을 제1정규화를 진행하면 아래와 같다.

| id   | 이름 | 나이 | 수강과목 |
| ---- | ---- | ---- | -------- |
| 1    | 이더 | 21   | 중국어   |
| 2    | 이더 | 21   | 일본어   |
| 3    | 만호 | 22   | 독일어   |
| 4    | 보리 | 23   | 한국어   |

---

### 2) 2차 정규형 & 2차 정규화(2NF)

**2차 정규형**이란 **모든 속성은 기본키에 종속되어야 하고, 일부만 종속되는 것도 없어야 한다는 상태**이다. 다시 말해, 모든 비기본 속성들이 기본키 전체에 완전 함수 종속이 되어야 한다. **2차 정규화**는 **부분 함수의 종속성을 제거하는 방법**, 즉 기본키의 일부분에만 종속되는 부분적 종속성을 제거하는 작업이다. 이 과정이 개인적으로 복잡했던 부분이라 조금 더 자세히 파헤쳐 보겠다.

[ 학생_수강정보 ]

| 학생ID | 이름 | 나이 | 수강과목ID | 과목명 | 교수명 |
| ------ | ---- | ---- | ---------- | ------ | ------ |
| 1      | 이더 | 21   | C101       | 중국어 | 김교수 |
| 1      | 이더 | 21   | J202       | 일본어 | 박교수 |
| 2      | 만호 | 22   | D303       | 독일어 | 이교수 |
| 3      | 보리 | 23   | K404       | 한국어 | 최교수 |

제2정규화를 진행하기 위해선 1차 정규형을 만족하는 상태가 충족되어야 한다. 위 '학생_수강정보' 테이블은 모든 값이 원자적이고, 중첩된 테이블이나 중복된 열이 없기 때문에 1차 정규형이다. 

2차 정규화를 진행할 때 선행되어야 하는 것은 기본키가 무엇인지 확인하는 것이다. 이 테이블에서 기본키는 `학생ID`와 `수강과목ID`이다. 하지만 의미론적으로 `이름`과 `나이`는 `학생ID`에만 종속되고, `과목명`과 `교수명`은 `수강과목ID`에만 종속된다. 이것이 바로 **부분적 종속성**이다. 거꾸로 말해서, 부분적 종속성은 기본키가 2개 이상인 복합키인 경우에만 발생할 수 있는 문제이다. 이 부분을 해결하여 2차 정규화를 적용하면 결과는 아래와 같다.

[학생]

| 학생ID | 이름 | 나이 |
| ------ | ---- | ---- |
| 1      | 이더 | 21   |
| 2      | 만호 | 22   |
| 3      | 보리 | 23   |

[수강과목]

| 수강과목ID | 과목명 | 교수명 |
| ---------- | ------ | ------ |
| C101       | 중국어 | 김교수 |
| J202       | 일본어 | 박교수 |
| D303       | 독일어 | 이교수 |
| K404       | 한국어 | 최교수 |

[학생_수강과목]

| 학생ID | 수강과목ID |
| ------ | ---------- |
| 1      | C101       |
| 1      | J202       |
| 2      | D303       |
| 3      | K404       |

2차 정규화 결과, ''학생'' 테이블의 `이름`과 `나이`는 `학생ID`에 완전히 종속되며, '수강과목' 테이블의 `과목명`과 `교수명`은 `수강과목ID`에 완전히 종속된다. 부분적 종속성이 제거되었기 때문에, 이 테이블들은 2차 정규형이라고 말할 수 있다.

---

### 3) 3차 정규형 & 3차 정규화(3NF)

3차 정규화란 이행적 종속성(Transitive Dependency)을 제거하는 과정이고, 3차 정규화가 완료된 상태를 3차 정규형이라고 한다. 이행적 종석성이란, 만약 A → B, B → C 관계가 있을 때, A → C가 성립하는 경우를 의미한다. 

| 학생ID | 이름 | 학과ID | 학과명     | 학과장 |
| ------ | ---- | ------ | ---------- | ------ |
| 1      | 이더 | D101   | 컴퓨터공학 | 김교수 |
| 2      | 만호 | D102   | 기계공학   | 박교수 |
| 3      | 보리 | D101   | 컴퓨터공학 | 김교수 |

이 테이블에서 보면 `학과명`과 `학과장`이 `학과ID`에 종속된다. 즉, `학생ID`에 의해 `학과ID`가 결정되고, `학과ID`에 의해 `학과명`과 `학과장`이 결정된다. 이것이 바로 이행적 종속성이다. 만약 `김교수`의 이름이 `이교수`로 바뀐다면, 여러 레코드에서 수정해야 할 필요가 생긴다. 이는 데이터 무결성을 해칠 수 있다. 이 테이블에서 3차 정규화를 진행하여 이행적 종속성을 제거하면 결과는 아래와 같다.

[학생]

| 학생ID | 이름 | 학과ID |
| ------ | ---- | ------ |
| 1      | 이더 | D101   |
| 2      | 만호 | D102   |
| 3      | 보리 | D101   |

[학과]

| 학과ID | 학과명     | 학과장 |
| ------ | ---------- | ------ |
| D101   | 컴퓨터공학 | 김교수 |
| D102   | 기계공학   | 박교수 |

이제 ''학생'' 테이블에는 학생 정보와 학과 ID만 포함되며, 학과 정보는 '학과 테이블에서 관리되고, 이로 인해 학과 정보가 변경될 때 한 번만 수정하면 되므로 데이터의 일관성과 무결성이 높아진다.

---



### 4) 보이스-코드 정규형(BCNF)

BCNF는 3차 정규화를 강화한 형태로, 3차 정규형인 테이블에서 모든 결정자가 후보키여야 된다. BCNF는 3차 정규화로 해결할 수 없는 복잡한 종속성을 해결하기 위해 사용된다. BCNF를 적용하면 후보키가 아닌 결정자가 있을 경우, 테이블을 분리하여 BCNF조건을 만족시킬 수 있다. 정리하자면, **BCNF란 3차 정규화를 만족하면서 모든 결정자가 후보키 집합에 속한 정규형**이다.

💡결정자란? 다른 속성을 유일하게 결정하는 하나 이상의 속성의 집합이다. A가 B를 결정하는 결정자라고 하면 A -> B로 표현한다.

💡후보키란? 유일성과 최소성을 모두 만족하는 속성들의 집합이다.

아래는 3차 정규화(3NF)까지는 되어 있지만 BCNF는 만족하지 않는 테이블이다.

| 교수명 | 과목명       | 강의실 |
| ------ | ------------ | ------ |
| 김교수 | 데이터베이스 | 101    |
| 박교수 | 알고리즘     | 102    |
| 김교수 | 운영체제     | 103    |
| 이교수 | 데이터베이스 | 104    |

이 테이블에서는 `과목명`이 결정자인데, 후보키가 아니라는 점이 문제가 된다. `과목명`이 `강의실`을 결정하지만, `과목명` 자체는 유일하지 않기 때문에 후보키로 사용할 수 없기 때문이다. BCNF를 적용하면 아래와 같다.

[ 과목 ]

| 과목명       | 강의실 |
| ------------ | ------ |
| 데이터베이스 | 101    |
| 알고리즘     | 102    |
| 운영체제     | 103    |

[ 강의 ]

| 교수명 | 과목명       |
| ------ | ------------ |
| 김교수 | 데이터베이스 |
| 박교수 | 알고리즘     |
| 김교수 | 운영체제     |
| 이교수 | 데이터베이스 |

BCNF 결과, 과목명이 결정자인 동시에 후보키가 되어 BCNF 조건을 충족하게 된다. 과목명이 후보키가 되어 가으이실을 유일하게 결정할 수 있게 되어서 데이터의 중복과 이상현상이 방지될 수 있다.



✍🏻 4차정규화, 5차정규화 



## 3. 단점

정규화는 반드시 필요한 부분이지만, 무조건적인 장점만 있는 것은 아니다.

1. 릴레이션 분해로 인한 조인 연산 증가

   데이터를 여러 테이블로 나누기 때문에 조인(Join) 연산이 많아질 수 있고, 이는 복잡한 쿼리를 작성하게 하고 CPU와 메모리를 많이 사용한다는 점에서 성능을 저하시킬 수 있다. 실제 현업에서 작은 규모의 회사였음에도 한 테이블에 20개의 조인이 있어서 기능 하나를 개발하더라도 상당히 고심하며 많은 신경을 썼었던 기억이 난다.

2. 구조의 복잡성 증가

   정규화된 데이터베이스 구조는 비정규화된 구조에 비해 복잡해질 수 있다는 점에서 이를 이해하고 유지하는데 더 많은 리소스가 들 수 있다.

이런 단점들로 일부로 정규화된 데이터베이스 구조를 비정규화하는 경우도 심심치 않게 있다.

# 반정규화

## 1. 개념

반정규화(=비정규화, 역정규화)란 데이터베이스의 성능 향상을 위해서 데이터 중복을 허용하고 조인을 줄이는 과정이다.



## 2. 장단점

### 1) 장점

1. 쿼리 성능 개선

   데이터를 중복저장함으로써 복잡한 조인 연산을 줄일 수 있다는 점에서 쿼리 성능을 개선할 수 있다. 예를 들어, 자주 조회되는 데이터를 하나의 테이블에 저장하여 조인없이 직접 접근할 수 있다.

2. Read 작업 최적화

   읽기 작업이 많은 시스템에서는 반정규화를 통해 접근 속도를 높일 수 있다.

3. 사용자 경험 개선

   빠른 응답 시간으로 사용자 인터페이스에서 사용자 편의성이 개선될 수 있다.

### 2) 단점

1. 데이터 중복

​	중복된 데이터로 인해 무결성과 일관성 문제가 발생할 수 있다.

2. 저장 공간 증가

   중복된 데이터와 추가 필드로 인해 저장 공간이 증가할 수 있다.

3. 유지 보수 어려움

   반정규화된 데이터베이스 구조는 변경이나 유지보수가 더 복잡해 질 수 있다.



## 3. 방법

1. 중복 데이터 저장

   자주 조회되는 집계 데이터를 별도의 테이블에 중복 저장하여 조인 없이 빠르게 접근할 수 있다.

2. 집계 테이블 생성

   원본 테이블들에서 계산된 집계 결과(합계, 평균 등)를 저장하는 테이블을 추가하여 성능을 개선할 수 있다. 예를 들어, 판매 데이터를 요약하여 판매 총액을 저장하는 테이블을 만들 수 있다.

3. 조인 테이블 통합

   여러 테이블을 조인하는 대신, 자주 조인되는 테이블을 하나의 테이블로 통합하여 성능을 향상 시킬 수 있다. 예를 들어, 고객과 주문 정보를 하나의 테이블에 통합해놓고 조회할 경우 빠른 조회가 가능하다.



# 결론

정규화와 반정규화는 모두 데이터베이스의 성능을 향상시키기 위한 방법이기 때문에 각각의 장단점을 잘 파악하고 적절히 조합하여 실무에 알맞게 적용해야 한다.







---



참고

https://dev-coco.tistory.com/63

https://open-n-job.tistory.com/entry/DB-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%A0%95%EA%B7%9C%ED%99%94

https://mjn5027.tistory.com/46
